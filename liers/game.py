from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
import secrets
from .models import Rank, Card, Player


def _fresh_deck() -> List[Card]:
    # –í—Å–µ–≥–æ 28 –∫–∞—Ä—Ç: 8K, 8Q, 8J, 4TR (–¥–∂–æ–∫–µ—Ä—ã/–∫–æ–∑—ã—Ä–∏)
    deck: List[Card] = []
    deck += [Card(rank=Rank.K) for _ in range(8)]
    deck += [Card(rank=Rank.Q) for _ in range(8)]
    deck += [Card(rank=Rank.J) for _ in range(8)]
    deck += [Card(rank=Rank.TR) for _ in range(4)]
    return deck


@dataclass
class LastPlay:
    player_id: int
    actual_rank: Rank
    claimed_rank: Rank


@dataclass
class GameState:
    chat_id: int
    players: List[Player] = field(default_factory=list)
    started: bool = False
    deck: List[Card] = field(default_factory=_fresh_deck)
    hands: Dict[int, List[Card]] = field(default_factory=dict)
    current_topic: Optional[Rank] = None
    current_idx: int = 0  # –∏–Ω–¥–µ–∫—Å –≤ self.players
    last_play: Optional[LastPlay] = None
    alive: Dict[int, bool] = field(default_factory=dict)
    revolvers: Dict[int, int] = field(default_factory=dict)  # per-player remaining chambers (start 6)

    def reset(self):
        self.started = False
        self.deck = _fresh_deck()
        self.hands.clear()
        self.current_topic = None
        self.current_idx = 0
        self.last_play = None
        self.alive = {p.user_id: True for p in self.players}
        self.revolvers = {p.user_id: 6 for p in self.players}

    # --- –õ–æ–±–±–∏ ---
    def add_player(self, uid: int, username: str):
        if any(p.user_id == uid for p in self.players):
            return
        self.players.append(Player(uid, username or str(uid)))
        self.alive[uid] = True
        self.revolvers[uid] = 6

    def remove_dead(self):
        self.players = [p for p in self.players if self.alive.get(p.user_id, False)]
        if self.current_idx >= len(self.players):
            self.current_idx = 0

    # --- –†–∞–∑–¥–∞—á–∞ –∏ —Å—Ç–∞—Ä—Ç ---
    def start(self):
        if self.started:
            raise ValueError("–ò–≥—Ä–∞ —É–∂–µ –Ω–∞—á–∞—Ç–∞.")
        if len(self.players) < 2:
            raise ValueError("–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –∏–≥—Ä–æ–∫–∞.")
        self.reset()
        if len(self.players) * 5 > len(self.deck):
            raise ValueError("–ú–∞–∫—Å–∏–º—É–º 6 –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–ª–æ–¥—ã (28 –∫–∞—Ä—Ç –ø–æ 5 –Ω–∞ –∏–≥—Ä–æ–∫–∞).")
        # –ü–µ—Ä–µ—Ç–∞—Å–æ–≤–∫–∞ —á–µ—Ä–µ–∑ secrets (–∫—Ä–∏–ø—Ç–æ—É—Å—Ç–æ–π—á–∏–≤—ã–π —Ä–∞–Ω–¥–æ–º)
        deck = self.deck
        for i in range(len(deck) - 1, 0, -1):
            j = secrets.randbelow(i + 1)
            deck[i], deck[j] = deck[j], deck[i]
        # –†–∞–∑–¥–∞—á–∞ –ø–æ 5 –∫–∞—Ä—Ç
        for p in self.players:
            self.hands[p.user_id] = [self.deck.pop() for _ in range(5)]
        # –¢–µ–º–∞
        self.current_topic = secrets.choice([Rank.K, Rank.Q, Rank.J])
        # –°—Ç–∞—Ä—Ç–æ–≤—ã–π –∏–≥—Ä–æ–∫
        self.current_idx = secrets.randbelow(len(self.players))
        self.started = True
        self.last_play = None

    def draw_if_possible(self, uid: int):
        # –î–æ–±–æ—Ä –ø—Ä–∏ –ø—É—Å—Ç–æ–π —Ä—É–∫–µ
        if not self.hands[uid] and self.deck:
            # –µ—Å–ª–∏ –∫–æ–ª–æ–¥–∞ –∫–æ–Ω—á–∏–ª–∞—Å—å ‚Äî –Ω–æ–≤–∞—è —Å–¥–∞—á–∞
            to_draw = min(5, len(self.deck))
            self.hands[uid] = [self.deck.pop() for _ in range(to_draw)]
            # –ø—Ä–∏ –Ω–æ–≤–æ–π —Ñ–∞–∑–µ –¥–æ–±–æ—Ä–∞ –º–æ–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Ç–µ–º—É
            if self.current_topic is None:
                self.current_topic = secrets.choice([Rank.K, Rank.Q, Rank.J])

    # --- –•–æ–¥ –∏ –æ–±–≤–∏–Ω–µ–Ω–∏–µ ---
    def _topup_player_to_five(self, uid: int) -> None:
        """–î–æ–±—Ä–∞—Ç—å –∫–∞—Ä—Ç—ã —ç—Ç–æ–º—É –∏–≥—Ä–æ–∫—É –¥–æ 5, –µ—Å–ª–∏ –≤ –∫–æ–ª–æ–¥–µ –µ—Å—Ç—å –∫–∞—Ä—Ç—ã."""
        hand = self.hands.setdefault(uid, [])
        while len(hand) < 5 and self.deck:
            hand.append(self.deck.pop())

    def _topup_alive_to_five(self) -> None:
        """–î–æ–±—Ä–∞—Ç—å –≤—Å–µ–º –∂–∏–≤—ã–º –∏–≥—Ä–æ–∫–∞–º –¥–æ 5 –∫–∞—Ä—Ç (–ø–æ –ø–æ—Ä—è–¥–∫—É —Å–ø–∏—Å–∫–∞ –∏–≥—Ä–æ–∫–æ–≤)."""
        for p in self.players:
            if self.alive.get(p.user_id, False):
                self._topup_player_to_five(p.user_id)

    def _redeal_alive_to_five(self, last_play_rank: Optional[Rank] = None) -> None:
        """–ü–æ–ª–Ω–∞—è –∑–∞–º–µ–Ω–∞ —Ä—É–∫: —Å–æ–±—Ä–∞—Ç—å –≤—Å–µ –∫–∞—Ä—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –≤ –∫–æ–ª–æ–¥—É, –ø–µ—Ä–µ–º–µ—à–∞—Ç—å –∏ —Ä–∞–∑–¥–∞—Ç—å –ø–æ 5 –∂–∏–≤—ã–º."""
        # –°–æ–±—Ä–∞—Ç—å –≤—Å–µ –∫–∞—Ä—Ç—ã –∏–∑ —Ä—É–∫ –≤ –∫–æ–ª–æ–¥—É
        for uid, hand in list(self.hands.items()):
            if hand:
                self.deck.extend(hand)
                self.hands[uid] = []
        # –í–µ—Ä–Ω—É—Ç—å –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—ã–≥—Ä–∞–Ω–Ω—É—é –∫–∞—Ä—Ç—É –≤ –∫–æ–ª–æ–¥—É (–µ—Å–ª–∏ –µ—Å—Ç—å)
        if last_play_rank is not None:
            self.deck.append(Card(rank=last_play_rank))
        # –ü–µ—Ä–µ—Ç–∞—Å–æ–≤–∞—Ç—å –∫–æ–ª–æ–¥—É
        deck = self.deck
        for i in range(len(deck) - 1, 0, -1):
            j = secrets.randbelow(i + 1)
            deck[i], deck[j] = deck[j], deck[i]
        # –†–∞–∑–¥–∞—Ç—å –ø–æ 5 –∂–∏–≤—ã–º –∏–≥—Ä–æ–∫–∞–º
        for p in self.players:
            if self.alive.get(p.user_id, False):
                self.hands[p.user_id] = []
                for _ in range(5):
                    if not self.deck:
                        break
                    self.hands[p.user_id].append(self.deck.pop())

    def current_player(self) -> Player:
        return self.players[self.current_idx]

    def play(self, uid: int, hand_index: int, claimed_rank: Rank) -> LastPlay:
        if not self.started:
            raise ValueError("–ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞.")
        if uid != self.current_player().user_id:
            raise ValueError("–°–µ–π—á–∞—Å –Ω–µ –≤–∞—à —Ö–æ–¥.")
        if self.current_topic is None:
            raise ValueError("–¢–µ–º–∞ –Ω–µ –∑–∞–¥–∞–Ω–∞.")
        hand = self.hands.get(uid, [])
        if hand_index < 0 or hand_index >= len(hand):
            raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π –∏–Ω–¥–µ–∫—Å –∫–∞—Ä—Ç—ã.")
        actual_card = hand.pop(hand_index)
        self.last_play = LastPlay(player_id=uid, actual_rank=actual_card.rank, claimed_rank=claimed_rank)
        # –ü–µ—Ä–µ—Ö–æ–¥ —Ö–æ–¥–∞ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –∂–∏–≤–æ–º—É
        self.current_idx = self._next_alive_idx(self.current_idx)
        # –¥–æ–±–æ—Ä –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
        self.draw_if_possible(uid)
        return self.last_play

    def _next_alive_idx(self, idx: int) -> int:
        n = len(self.players)
        for _ in range(n):
            idx = (idx + 1) % n
            pid = self.players[idx].user_id
            if self.alive.get(pid, False):
                return idx
        return idx  # –µ—Å–ª–∏ –æ—Å—Ç–∞–ª—Å—è –æ–¥–∏–Ω, –≤–µ—Ä–Ω—ë–º –∫–∞–∫ –µ—Å—Ç—å

    def accuse(self, accuser_uid: int) -> Tuple[str, bool, Optional[int]]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (—Å–æ–æ–±—â–µ–Ω–∏–µ, –≤—ã—Å—Ç—Ä–µ–ª_—Å–ª—É—á–∏–ª—Å—è, –ø–æ–≥–∏–±—à–∏–π_uid|None)
        """
        if not self.started:
            raise ValueError("–ò–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞—Ç–∞.")
        if self.last_play is None:
            raise ValueError("–ù–µ—á–µ–≥–æ –æ—Å–ø–∞—Ä–∏–≤–∞—Ç—å.")
        # –æ–±–≤–∏–Ω—è—Ç—å –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∏–π –ø–æ –æ—á–µ—Ä–µ–¥–∏ (—Å–ª–µ–¥—É—é—â–∏–π –ø–æ—Å–ª–µ –∏–≥—Ä–æ–∫–∞, –∫–æ—Ç–æ—Ä—ã–π —É–∂–µ –ø–æ—Ö–æ–¥–∏–ª)
        if accuser_uid != self.current_player().user_id:
            raise ValueError("–û–±–≤–∏–Ω—è—Ç—å –º–æ–∂–µ—Ç —Ç–æ–ª—å–∫–æ —Å–ª–µ–¥—É—é—â–∏–π –∏–≥—Ä–æ–∫ –ø–æ –æ—á–µ—Ä–µ–¥–∏.")

        lp = self.last_play
        # –û—Å–æ–±–æ–µ –ø—Ä–∞–≤–∏–ª–æ —Ç–µ–º—ã: –µ—Å–ª–∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –∫–∞—Ä—Ç–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å —Ç–µ–º–æ–π,
        # –Ω–∞–∫–∞–∑–∞–Ω–∏–µ –ø–æ–ª—É—á–∞–µ—Ç –æ–±–≤–∏–Ω–∏—Ç–µ–ª—å (—Å—Ç—Ä–µ–ª—è–µ—Ç –≤ —Å–µ–±—è)
        if self.current_topic is not None and lp.actual_rank == self.current_topic:
            liar_caught = False
            punished_uid = accuser_uid
        else:
            liar_caught = (lp.actual_rank != lp.claimed_rank)
            punished_uid = lp.player_id if liar_caught else accuser_uid

        # –†—É—Å—Å–∫–∞—è —Ä—É–ª–µ—Ç–∫–∞: –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π –±–∞—Ä–∞–±–∞–Ω –Ω–∞ –∏–≥—Ä–æ–∫–∞ (1/6 ‚Üí 1/5 ‚Üí ... ‚Üí 1/1)
        remaining = self.revolvers.get(punished_uid, 6)
        if remaining < 1:
            remaining = 1
        bullet = secrets.randbelow(remaining) == 0
        died_uid: Optional[int] = None
        if bullet:
            self.alive[punished_uid] = False
            died_uid = punished_uid
            # –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∏–º –±–∞—Ä–∞–±–∞–Ω –Ω–∞–∫–∞–∑–∞–Ω–Ω–æ–≥–æ (–µ—Å–ª–∏ –æ–Ω –≤—ã–∂–∏–ª –±—ã –≤ –±—É–¥—É—â–µ–º)
            self.revolvers[punished_uid] = 6
            self.remove_dead()
        else:
            # –©–µ–ª—á–æ–∫ ‚Äî —à–∞–Ω—Å –¥–ª—è —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø–æ–≤—ã—à–∞–µ—Ç—Å—è
            next_remaining = max(1, remaining - 1)
            self.revolvers[punished_uid] = next_remaining

        # –ü–æ—Å–ª–µ –æ–±–≤–∏–Ω–µ–Ω–∏—è ¬´–≤—Å–∫—Ä—ã–ª–∏—Å—å¬ª ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º last_play
        self.last_play = None

        # –ü–æ—Å–ª–µ –æ–±–≤–∏–Ω–µ–Ω–∏—è –ø–æ–ª–Ω–æ—Å—Ç—å—é –º–µ–Ω—è–µ–º —Ä—É–∫–∏: –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ –∫–∞—Ä—Ç—ã –≤ –∫–æ–ª–æ–¥—É, —Ç–∞—Å—É–µ–º –∏ —Ä–∞–∑–¥–∞—ë–º –ø–æ 5 –∂–∏–≤—ã–º
        self._redeal_alive_to_five(last_play_rank=lp.actual_rank)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã
        alive_players = [p for p in self.players if self.alive.get(p.user_id, False)]
        winner_text = ""
        if len(alive_players) == 1:
            winner = alive_players[0]
            self.started = False
            winner_text = f"\nüèÜ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: @{winner.username}!"

        if liar_caught:
            msg = f"–õ–∂–µ—Ü –ø–æ–π–º–∞–Ω! @{self._name(lp.player_id)} –ø–æ–ª–æ–∂–∏–ª {lp.actual_rank}, –∞ –∑–∞—è–≤–∏–ª {lp.claimed_rank}."
        else:
            msg = f"–û–±–≤–∏–Ω–µ–Ω–∏–µ –ø—Ä–æ–≤–∞–ª–∏–ª–æ—Å—å! @{self._name(lp.player_id)} –±—ã–ª —á–µ—Å—Ç–µ–Ω: {lp.actual_rank}."

        if bullet:
            msg += f"\nüî´ –†—É—Å—Å–∫–∞—è —Ä—É–ª–µ—Ç–∫–∞: @{self._name(punished_uid)} –Ω–µ –≤—ã–∂–∏–ª."
        else:
            nxt = self.revolvers.get(punished_uid, 6)
            hint = f"1/{nxt}" if nxt > 1 else "1/1"
            msg += f"\nüî´ –†—É—Å—Å–∫–∞—è —Ä—É–ª–µ—Ç–∫–∞: —â–µ–ª—á–æ–∫... –ø–æ–≤–µ–∑–ª–æ @{self._name(punished_uid)}! (—Å–ª–µ–¥—É—é—â–∏–π —à–∞–Ω—Å {hint})"

        msg += winner_text
        return msg, bullet, died_uid

    def _name(self, uid: int) -> str:
        for p in self.players:
            if p.user_id == uid:
                return p.username
        return str(uid)

    def status(self) -> str:
        if not self.players:
            return "–õ–æ–±–±–∏ –ø—É—Å—Ç–æ–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /join."
        alive_marks = {uid: ("üü¢" if self.alive.get(uid, False) else "‚ö´Ô∏è") for uid in self.alive}
        order = " ‚Üí ".join([f"@{p.username}{alive_marks.get(p.user_id,'')}" for p in self.players])
        cur = self.current_player().username if self.started else "‚Äî"
        topic = self.current_topic.value if self.current_topic else "‚Äî"
        pending = ""
        if self.last_play:
            pending = f"\n–ü–æ—Å–ª–µ–¥–Ω–∏–π —Ö–æ–¥: @{self._name(self.last_play.player_id)} –∑–∞—è–≤–∏–ª {self.last_play.claimed_rank} (–∫–∞—Ä—Ç–∞ —Å–∫—Ä—ã—Ç–∞)."
        return f"–ò–≥—Ä–æ–∫–∏: {order}\n–¢–µ–º–∞: {topic}\n–•–æ–¥: @{cur}{pending}"

    def hand_str(self, uid: int) -> str:
        cards = self.hands.get(uid, [])
        if not cards:
            return "–†—É–∫–∞ –ø—É—Å—Ç–∞."
        return "–í–∞—à–∞ —Ä—É–∫–∞:\n" + "\n".join([f"{i}: {c.rank}" for i, c in enumerate(cards)])

    def stop(self) -> str:
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å –∏–≥—Ä—É."""
        self.started = False
        self.deck = []
        self.hands.clear()
        self.current_topic = None
        self.current_idx = 0
        self.last_play = None
        self.alive.clear()
        self.revolvers.clear()
        return "‚ùå –ò–≥—Ä–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."
